#!/usr/bin/env python3

# TODO
# - write (inline) documentation
# - leaf-only (default)

import argparse
import os
import sys

# Setting up logging 
import logging
# log_formatter = logging.Formatter('%(asctime)s [%(levelname)7s] (%(filename)16s:%(lineno)4s - %(funcName)20s()) %(message)s')
log_formatter = logging.Formatter('%(message)s')
loglevel = logging.DEBUG
log = logging.getLogger('binpack')
log.setLevel(loglevel)

spinner = None

def spinning_cursor():
	"""Spinning Cursor to keep the user informed that something happens
	"""
	while True:
		for cursor in '|/-\\':
			yield cursor



class ArtworkExtractor:

	# Recurse into subdirectories
	recursive = False
	recursion_limit = 255

	# Usually one leaf directories (dirs that do not contain other directories)
	# are processed because this is typically the location where media files
	# are stored in a media library.
	# If needed, you can process all directories by providing the -a/--all-dirs
	# option
	all_dirs = False

	# Dry-run mode, do not make any changes on the file system
	dry_run = False

	# Show a summary what has been done after finishing
	# show_summary = False

	# List of directories that hold the media files where we try to extract
	# the album cover artwork from. If not specified we should use the
	# current directory.
	directory = []

	# Sidecar files
	sidecar_filename = None
	sidecar_quality = 75

	# Timestamps
	ts_start = None
	ts_stop = None

	def __init__(self):
		"""Initializer and main function of the script.
		"""
		global log
		if len(log.handlers) == 0:
			stdout = logging.StreamHandler()
			# stdout.setFormatter(log_formatter)
			log.addHandler(stdout)
			log.setLevel(loglevel)

		# Initialize the spinner (rotating thing when -v mode)
		global spinner
		spinner = spinning_cursor()

		self.parse_args()
		if self.dry_run:
			log.warn("Dry run: running script in simulation mode")

		log.debug("Recursion limit set to {}".format(self.recursion_limit))
		sys.setrecursionlimit(self.recursion_limit)

		# Scan for all directories in the specified self.directory
		directories = self.get_directories(self.directory, recursive = self.recursive, leafs = not self.all_dirs)
		log.info ("Found {} dir(s)".format(len(directories)))
		log.debug("Processing dir(s): {}".format("\n".join(directories)))



	def parse_args(self):
		"""
		This function parses the arguments passed to the script by the
		command line.
		"""
		description = "awe extracts cover artwork from music files and saves it to a file in the each album's directory."
		epilog = "{my_name}, Python {py_version_maj}.{py_version_min}.{py_version_tiny}".format(my_name = self.__class__.__name__, py_version_maj = sys.version_info[0], py_version_min = sys.version_info[1], py_version_tiny = sys.version_info[2])

		parser = argparse.ArgumentParser(description = description, epilog="{epilog}".format(epilog=epilog), conflict_handler="resolve")

		# Directory options
		parser.add_argument("dir", nargs="*", action="store", help="Directory that contains the music files. If none given, the current directory will be used.", default=".")
		parser.add_argument("-a", "--all-dirs", action="store_true", dest="all_dirs", help="Usually only leaf directories (dirs that do not contain other dirs) are processed. If you want to process all directories and put sidecar files to it you can specify this option.", default=False, required=False)
		parser.add_argument("-r", "--recursive", action="store_true", dest="recursive", help="Dive into subdirectories. Useful if you want to use awe for complete music collections.", default=False, required=False)
		parser.add_argument("--recursion-limit", action="store", dest="limit", help="Extend the maximum recursion depth when diving into subdirectories. Default is 255.", default=255, required=False)

		# Output options
		parser.add_argument("-f", "--force", action="store_true", dest="force", help="Overwrite already existing sidecar files.", default=False, required=False)
		parser.add_argument("-n", "--name", action="store", dest="name", help="Name of the sidecar file to write in each folder that contains media files with embedded album artwork. Default is folder.jpg.", default="folder.jpg", required=False)
		parser.add_argument("-q", "--quality", action="store", dest="quality", help="Quality of the sidecar jpg file to store with 0 <= QUALITY <= 100. Default is 75.", default=75, required=False)

		# verbosity options
		verbosity_group = parser.add_mutually_exclusive_group()
		verbosity_group.add_argument("--quiet", action="store_true", dest="quiet", help="Do not print anything to stdout but error messages.", default=False, required=False)
		verbosity_group.add_argument("-v", "--verbose", action="count", dest="verbosity", help="Be more verbose what happens.", default=0, required=False)

		# simulating
		parser.add_argument("--dry-run", action="store_true", dest="dry_run", help="Do not write any cover artwork files to disk or change anything else. This simulates a run and shows whats going on.", default=False)
		# parser.add_argument("-s", "--summary", action="store_true", dest="show_summary", help="Prints a summary after finishing the run.", default=False)

		# misc options
		# parser.add_argument("--version", action="version", help="Show version information and exit.", version=epilog)



		# if an error occurs the help will be displayed automatically
		try:
			results = parser.parse_args()
		except:
			# parser.print_help()
			sys.exit(0)

		# set log level depending on verbosity
		# if quiet is set, set log level to ERROR level
		# if results.quiet:
		# 	log.setLevel(logging.ERROR)
		if results.verbosity == 0:
			# default behavior is neither -q nor -v* has been provided
			log.setLevel(logging.WARN)
		elif results.verbosity == 1:
			log.setLevel(logging.INFO)
		elif results.verbosity == 2:
			# if -vv or more is specified you can handle that here
			log.setLevel(logging.DEBUG)
		else: # results.verbosity >= 3:
			# even more -v's: change logformatter and enable extended debug ouput
			log.setLevel(logging.DEBUG)

			for handler in log.handlers:
				handler.setFormatter(logging.Formatter('%(asctime)s [%(levelname)7s] (%(filename)16s:%(lineno)4s - %(funcName)20s()) %(message)s'))

		# log.debug("Log level set to {log_level}".format(log_level=logging.getLevelName(log.level)))
		# log.debug("Parsed arguments: {}".format(results))

		### Sanity checks

		# results.name is valid file name

		# results.quality is 0 <= int <= 100

		### Save values
		# Store variables depending on the arguments given on the command line
		self.recursive = results.recursive
		self.recursion_limit = int(results.limit)
		self.all_dirs = results.all_dirs
		self.dry_run = results.dry_run
		self.directory = list(results.dir)
		self.sidecar_filename = results.name
		self.sidecar_quality = results.quality
		# self.show_summary = results.show_summary



	def get_directories(self, base_dirs, recursive = False, leafs = True):
		"""Get list of directories in a base_dir.

		:param base_dir: List of base directories to scan
		:param recursive: If True, dive into subdirectories
		:param leafs: If True, return only dirs that contain no other dirs
		:return: List of directories in base_dir
		"""
		# log.debug("get_directories(): {}".format(base_dirs))
		result = []
		for d in base_dirs:
			# some preprocessing: expand variables and user dirs
			de = os.path.expandvars(os.path.expanduser(d))

			if not os.path.exists(de) or not os.path.isdir(de):
				log.warn("Directory {} does not exist".format(de))
				continue
			if not os.access(de, os.R_OK):
				log.warn("Cannot access {}".format(de))
				continue


			# if log.level == logging.INFO:
			# 	sys.stdout.write("\r[{}] {}".format(next(spinner), de))
			# 	sys.stdout.flush()

			# extend the result list with the real absolute path names
			# dirs = [ os.path.realpath(os.path.join(de, f)) for f in os.listdir(de) if os.access(os.path.join(de, f), os.X_OK) and os.path.isdir(os.path.join(de, f)) ]
			dirs = [ os.path.realpath(os.path.join(de, f)) for f in os.listdir(de) if os.path.isdir(os.path.join(de, f)) ]

			# dirs = []
			# try:
			# 	for f in os.listdir(de):
			# 		if os.path(isdir(os.path.join(de, f))):
			# 			dirs.append(f)
			# except Exception as e:
				# log.warn("Cannot read {}: {}".format(de, e))

			# If leafs = True we add our dir to the result set
			# if we do not contain any other directory
			if not leafs or len(dirs) == 0:
				result.append(str(d))

			if recursive:
				result.extend(self.get_directories(dirs, True, leafs = leafs))

		return result





if __name__ == '__main__':
	ArtworkExtractor()